//===-- VideocoreISelDAGToDAG.cpp - A dag to dag inst selector for Videocore ------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file defines an instruction selector for the VIDEOCORE target.
//
//===----------------------------------------------------------------------===//

#include "VideocoreTargetMachine.h"
#include "llvm/CodeGen/SelectionDAGISel.h"
#include "llvm/Support/Compiler.h"
#include "llvm/Support/DataTypes.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/ErrorHandling.h"
#include "llvm/Support/raw_ostream.h"
using namespace llvm;

//===----------------------------------------------------------------------===//
// Instruction Selector Implementation
//===----------------------------------------------------------------------===//

//===--------------------------------------------------------------------===//
/// VideocoreDAGToDAGISel - VIDEOCORE specific code to select VIDEOCORE machine
/// instructions for SelectionDAG operations.
///
namespace {
class VideocoreDAGToDAGISel : public SelectionDAGISel {
  /// Subtarget - Keep a pointer to the Videocore Subtarget around so that we can
  /// make the right decision when generating code for different targets.
  VideocoreTargetMachine& TM;
public:
  explicit VideocoreDAGToDAGISel(VideocoreTargetMachine &tm)
    : SelectionDAGISel(tm),
      TM(tm) {
  }

  SDNode *Select(SDNode *N);

  // Complex Pattern Selectors.
  bool SelectADDRrr(SDValue N, SDValue &R1, SDValue &R2);
  bool SelectADDRri(SDValue N, SDValue &Base, SDValue &Offset);

  bool SelectBITi(SDValue N, SDValue &imm);
  bool SelectNOTBITi(SDValue N, SDValue &imm);
  bool SelectMASKi(SDValue N, SDValue &imm);
  bool SelectNEGu5(SDValue N, SDValue &imm);


  /// SelectInlineAsmMemoryOperand - Implement addressing mode selection for
  /// inline asm expressions.
  virtual bool SelectInlineAsmMemoryOperand(const SDValue &Op,
                                            char ConstraintCode,
                                            std::vector<SDValue> &OutOps);

  virtual const char *getPassName() const {
    return "VIDEOCORE DAG->DAG Pattern Instruction Selection";
  }

  // Include the pieces autogenerated from the target description.
#include "VideocoreGenDAGISel.inc"

private:
};
}  // end anonymous namespace


bool VideocoreDAGToDAGISel::SelectADDRri(SDValue Addr,
                                     SDValue &Base, SDValue &Offset) {
  if (FrameIndexSDNode *FIN = dyn_cast<FrameIndexSDNode>(Addr)) {
    Base = CurDAG->getTargetFrameIndex(FIN->getIndex(), MVT::i32);
    Offset = CurDAG->getTargetConstant(0, MVT::i32);
    return true;
  }
  if (Addr.getOpcode() == ISD::TargetExternalSymbol ||
      Addr.getOpcode() == ISD::TargetGlobalAddress)
    return false;  // direct calls.

  if (Addr.getOpcode() == ISD::ADD) {
    if (ConstantSDNode *CN = dyn_cast<ConstantSDNode>(Addr.getOperand(1))) {
      if (isInt<13>(CN->getSExtValue())) {
        if (FrameIndexSDNode *FIN =
                dyn_cast<FrameIndexSDNode>(Addr.getOperand(0))) {
          // Constant offset from frame ref.
          Base = CurDAG->getTargetFrameIndex(FIN->getIndex(), MVT::i32);
        } else {
          Base = Addr.getOperand(0);
        }
        Offset = CurDAG->getTargetConstant(CN->getZExtValue(), MVT::i32);
        return true;
      }
    }
  }
  Base = Addr;
  Offset = CurDAG->getTargetConstant(0, MVT::i32);
  return true;
}

bool VideocoreDAGToDAGISel::SelectADDRrr(SDValue Addr, SDValue &R1, SDValue &R2) {
  if (Addr.getOpcode() == ISD::FrameIndex) return false;
  if (Addr.getOpcode() == ISD::TargetExternalSymbol ||
      Addr.getOpcode() == ISD::TargetGlobalAddress)
    return false;  // direct calls.

  if (Addr.getOpcode() == ISD::ADD) {
    if (ConstantSDNode *CN = dyn_cast<ConstantSDNode>(Addr.getOperand(1)))
      if (isInt<13>(CN->getSExtValue()))
        return false;  // Let the reg+imm pattern catch this!
    R1 = Addr.getOperand(0);
    R2 = Addr.getOperand(1);
    return true;
  }

  R1 = Addr;
  R2 = CurDAG->getRegister(VC::R0, MVT::i32);
  return true;
}

// Detect 32 bit constants that can be replaced with 1 << x
bool VideocoreDAGToDAGISel::SelectBITi(SDValue N, SDValue &imm) {
	if(ConstantSDNode *CN = dyn_cast<ConstantSDNode>(N)) {
		uint32_t v = CN->getZExtValue();
		// test if only one bit is set (aka, is a power of 2)
		if(v && !(v & (v - 1))) {
			int bit = 0x1f - __builtin_clz(v);
			imm = CurDAG->getTargetConstant(bit, MVT::i32);
			return true;
		}
	}
	return false;
}

// Detect 32 bit constants that can be replaced with ~(1 << x)
bool VideocoreDAGToDAGISel::SelectNOTBITi(SDValue N, SDValue &imm) {
	if(ConstantSDNode *CN = dyn_cast<ConstantSDNode>(N)) {
		uint32_t v = CN->getZExtValue();
		v = ~v;
		// test if only one bit is set (aka, is a power of 2)
		if(v && !(v & (v - 1))) {
			int bit = 0x1f - __builtin_clz(v);
			imm = CurDAG->getTargetConstant(bit, MVT::i32);
			return true;
		}
	}
	return false;
}

// Detect 32 bit constants that can be replaced with (1 << x) -1
bool VideocoreDAGToDAGISel::SelectMASKi(SDValue N, SDValue &imm) {
	if(ConstantSDNode *CN = dyn_cast<ConstantSDNode>(N)) {
		uint32_t v = CN->getZExtValue();
		if(v == 0) return false; // clz is undefined for zero
		int topbit = 0x20 - __builtin_clz(v);
		// test if all bits below topbit are set
		if(v == (unsigned)(1 << topbit) - 1) {
			imm = CurDAG->getTargetConstant(topbit, MVT::i32);
			return true;
		}
	}
	return false;
}

// Match small negitave constants that 
bool VideocoreDAGToDAGISel::SelectNEGu5(SDValue N, SDValue &imm) {
	if(ConstantSDNode *CN = dyn_cast<ConstantSDNode>(N)) {
		int v = CN->getSExtValue();
		if(v < 0 && v > -32) {
			imm = CurDAG->getTargetConstant(abs(v), MVT::i32);
			return true;
		}
	}
	return false;
}




SDNode *VideocoreDAGToDAGISel::Select(SDNode *N) {
  //DebugLoc dl = N->getDebugLoc();
  if (N->isMachineOpcode())
    return NULL;   // Already selected.

  switch (N->getOpcode()) {
  default: break;
   }

  return SelectCode(N);
}


/// SelectInlineAsmMemoryOperand - Implement addressing mode selection for
/// inline asm expressions.
bool
VideocoreDAGToDAGISel::SelectInlineAsmMemoryOperand(const SDValue &Op,
                                                char ConstraintCode,
                                                std::vector<SDValue> &OutOps) {
  SDValue Op0, Op1;
  switch (ConstraintCode) {
  default: return true;
  case 'm':   // memory
   if (!SelectADDRrr(Op, Op0, Op1))
     SelectADDRri(Op, Op0, Op1);
   break;
  }

  OutOps.push_back(Op0);
  OutOps.push_back(Op1);
  return false;
}

/// createVideocoreISelDag - This pass converts a legalized DAG into a
/// VIDEOCORE-specific DAG, ready for instruction scheduling.
///
FunctionPass *llvm::createVideocoreISelDag(VideocoreTargetMachine &TM) {
  return new VideocoreDAGToDAGISel(TM);
}
